// Code generated by protoc-gen-go. DO NOT EDIT.
// source: content.proto

/*
Package content is a generated protocol buffer package.

It is generated from these files:
	content.proto

It has these top-level messages:
	Content
	ContentData
	ContentAttributes
	ContentRequest
	ContentIdRequest
	NewContentAttributes
	StoreContentRequest
	ExistingContentAttributes
	UpdateContentRequest
*/
package content

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "google.golang.org/genproto/protobuf/field_mask"
import google_protobuf2 "github.com/golang/protobuf/ptypes/timestamp"
import google_protobuf3 "github.com/golang/protobuf/ptypes/empty"
import _ "github.com/golang/protobuf/ptypes/any"
import dictybase_api_jsonapi "github.com/dictyBase/go-genproto/dictybaseapis/api/jsonapi"
import _ "github.com/dictyBase/go-genproto/dictybaseapis/api/jsonapi"
import _ "github.com/mwitkow/go-proto-validators"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Content struct {
	Data  *ContentData                 `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Links *dictybase_api_jsonapi.Links `protobuf:"bytes,2,opt,name=links" json:"links,omitempty"`
}

func (m *Content) Reset()                    { *m = Content{} }
func (m *Content) String() string            { return proto.CompactTextString(m) }
func (*Content) ProtoMessage()               {}
func (*Content) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Content) GetData() *ContentData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Content) GetLinks() *dictybase_api_jsonapi.Links {
	if m != nil {
		return m.Links
	}
	return nil
}

type ContentData struct {
	// The resource name
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Unique id
	Id         int64                        `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Attributes *ContentAttributes           `protobuf:"bytes,3,opt,name=attributes" json:"attributes,omitempty"`
	Links      *dictybase_api_jsonapi.Links `protobuf:"bytes,4,opt,name=links" json:"links,omitempty"`
}

func (m *ContentData) Reset()                    { *m = ContentData{} }
func (m *ContentData) String() string            { return proto.CompactTextString(m) }
func (*ContentData) ProtoMessage()               {}
func (*ContentData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ContentData) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ContentData) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ContentData) GetAttributes() *ContentAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *ContentData) GetLinks() *dictybase_api_jsonapi.Links {
	if m != nil {
		return m.Links
	}
	return nil
}

// Definition for various content fields
type ContentAttributes struct {
	// page name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// page slug. Look here https://en.wikipedia.org/wiki/Semantic_URL#Slug to know about slug
	Slug string `protobuf:"bytes,2,opt,name=slug" json:"slug,omitempty"`
	// id of the user who created the content
	CreatedBy int64 `protobuf:"varint,3,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	// id of the user who updated the content
	UpdatedBy int64 `protobuf:"varint,4,opt,name=updated_by,json=updatedBy" json:"updated_by,omitempty"`
	// Timestamp for creation and update
	CreatedAt *google_protobuf2.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	UpdatedAt *google_protobuf2.Timestamp `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
	// serialized page content(for example serialized draft js object)
	Content string `protobuf:"bytes,7,opt,name=content" json:"content,omitempty"`
	// namespace for the page
	Namespace string `protobuf:"bytes,8,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *ContentAttributes) Reset()                    { *m = ContentAttributes{} }
func (m *ContentAttributes) String() string            { return proto.CompactTextString(m) }
func (*ContentAttributes) ProtoMessage()               {}
func (*ContentAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ContentAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContentAttributes) GetSlug() string {
	if m != nil {
		return m.Slug
	}
	return ""
}

func (m *ContentAttributes) GetCreatedBy() int64 {
	if m != nil {
		return m.CreatedBy
	}
	return 0
}

func (m *ContentAttributes) GetUpdatedBy() int64 {
	if m != nil {
		return m.UpdatedBy
	}
	return 0
}

func (m *ContentAttributes) GetCreatedAt() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *ContentAttributes) GetUpdatedAt() *google_protobuf2.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *ContentAttributes) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *ContentAttributes) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type ContentRequest struct {
	// Url slug
	// Look here https://en.wikipedia.org/wiki/Semantic_URL#Slug to know about slug
	// The slug name should be unique
	Slug string `protobuf:"bytes,1,opt,name=slug" json:"slug,omitempty"`
}

func (m *ContentRequest) Reset()                    { *m = ContentRequest{} }
func (m *ContentRequest) String() string            { return proto.CompactTextString(m) }
func (*ContentRequest) ProtoMessage()               {}
func (*ContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ContentRequest) GetSlug() string {
	if m != nil {
		return m.Slug
	}
	return ""
}

type ContentIdRequest struct {
	// Unique id to identify content
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *ContentIdRequest) Reset()                    { *m = ContentIdRequest{} }
func (m *ContentIdRequest) String() string            { return proto.CompactTextString(m) }
func (*ContentIdRequest) ProtoMessage()               {}
func (*ContentIdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ContentIdRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// Definition for fields that are needed for storing the content
type NewContentAttributes struct {
	// page name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// user id who is creating this content
	// The existence of user will be verified(not implemented yet)
	// using the `user` microservice backend.
	CreatedBy int64 `protobuf:"varint,2,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	// page content, expected to be serialized `JSON` string.
	Content string `protobuf:"bytes,3,opt,name=content" json:"content,omitempty"`
	// namespace for the page, it is prepended to the
	// name to generate an unique slug.
	Namespace string `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *NewContentAttributes) Reset()                    { *m = NewContentAttributes{} }
func (m *NewContentAttributes) String() string            { return proto.CompactTextString(m) }
func (*NewContentAttributes) ProtoMessage()               {}
func (*NewContentAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NewContentAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NewContentAttributes) GetCreatedBy() int64 {
	if m != nil {
		return m.CreatedBy
	}
	return 0
}

func (m *NewContentAttributes) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *NewContentAttributes) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Definition for storing new content
type StoreContentRequest struct {
	Data *StoreContentRequest_Data `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *StoreContentRequest) Reset()                    { *m = StoreContentRequest{} }
func (m *StoreContentRequest) String() string            { return proto.CompactTextString(m) }
func (*StoreContentRequest) ProtoMessage()               {}
func (*StoreContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *StoreContentRequest) GetData() *StoreContentRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type StoreContentRequest_Data struct {
	// resource name
	Type       string                `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Attributes *NewContentAttributes `protobuf:"bytes,2,opt,name=attributes" json:"attributes,omitempty"`
}

func (m *StoreContentRequest_Data) Reset()                    { *m = StoreContentRequest_Data{} }
func (m *StoreContentRequest_Data) String() string            { return proto.CompactTextString(m) }
func (*StoreContentRequest_Data) ProtoMessage()               {}
func (*StoreContentRequest_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *StoreContentRequest_Data) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *StoreContentRequest_Data) GetAttributes() *NewContentAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// Fields that can be updated
// Changing either or both of name and namespace
// attributes alter the slug for the page
type ExistingContentAttributes struct {
	// user id who is updating this content
	// The existence of user will be verified(not implemented yet)
	// using the `user` microservice backend.
	UpdatedBy int64 `protobuf:"varint,1,opt,name=updated_by,json=updatedBy" json:"updated_by,omitempty"`
	// serialized page content(for example serialized draft js object)
	Content string `protobuf:"bytes,2,opt,name=content" json:"content,omitempty"`
}

func (m *ExistingContentAttributes) Reset()                    { *m = ExistingContentAttributes{} }
func (m *ExistingContentAttributes) String() string            { return proto.CompactTextString(m) }
func (*ExistingContentAttributes) ProtoMessage()               {}
func (*ExistingContentAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ExistingContentAttributes) GetUpdatedBy() int64 {
	if m != nil {
		return m.UpdatedBy
	}
	return 0
}

func (m *ExistingContentAttributes) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type UpdateContentRequest struct {
	Data *UpdateContentRequest_Data `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Id   int64                      `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// An optional mask specifying which fields to update.
	// Presence of this field allow partial updates.
	UpdateMask *google_protobuf1.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateContentRequest) Reset()                    { *m = UpdateContentRequest{} }
func (m *UpdateContentRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateContentRequest) ProtoMessage()               {}
func (*UpdateContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UpdateContentRequest) GetData() *UpdateContentRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UpdateContentRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateContentRequest) GetUpdateMask() *google_protobuf1.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type UpdateContentRequest_Data struct {
	// resource name
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// unique id
	Id         int64                      `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Attributes *ExistingContentAttributes `protobuf:"bytes,3,opt,name=attributes" json:"attributes,omitempty"`
}

func (m *UpdateContentRequest_Data) Reset()                    { *m = UpdateContentRequest_Data{} }
func (m *UpdateContentRequest_Data) String() string            { return proto.CompactTextString(m) }
func (*UpdateContentRequest_Data) ProtoMessage()               {}
func (*UpdateContentRequest_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *UpdateContentRequest_Data) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *UpdateContentRequest_Data) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateContentRequest_Data) GetAttributes() *ExistingContentAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func init() {
	proto.RegisterType((*Content)(nil), "dictybase.content.Content")
	proto.RegisterType((*ContentData)(nil), "dictybase.content.ContentData")
	proto.RegisterType((*ContentAttributes)(nil), "dictybase.content.ContentAttributes")
	proto.RegisterType((*ContentRequest)(nil), "dictybase.content.ContentRequest")
	proto.RegisterType((*ContentIdRequest)(nil), "dictybase.content.ContentIdRequest")
	proto.RegisterType((*NewContentAttributes)(nil), "dictybase.content.NewContentAttributes")
	proto.RegisterType((*StoreContentRequest)(nil), "dictybase.content.StoreContentRequest")
	proto.RegisterType((*StoreContentRequest_Data)(nil), "dictybase.content.StoreContentRequest.Data")
	proto.RegisterType((*ExistingContentAttributes)(nil), "dictybase.content.ExistingContentAttributes")
	proto.RegisterType((*UpdateContentRequest)(nil), "dictybase.content.UpdateContentRequest")
	proto.RegisterType((*UpdateContentRequest_Data)(nil), "dictybase.content.UpdateContentRequest.Data")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ContentService service

type ContentServiceClient interface {
	// Gets the content of specified page(slug)
	GetContentBySlug(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*Content, error)
	GetContent(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*Content, error)
	// Store the content of a new page(slug)
	StoreContent(ctx context.Context, in *StoreContentRequest, opts ...grpc.CallOption) (*Content, error)
	// Update the content of an existing page
	UpdateContent(ctx context.Context, in *UpdateContentRequest, opts ...grpc.CallOption) (*Content, error)
	// Delete an existing page along with its content
	DeleteContent(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
}

type contentServiceClient struct {
	cc *grpc.ClientConn
}

func NewContentServiceClient(cc *grpc.ClientConn) ContentServiceClient {
	return &contentServiceClient{cc}
}

func (c *contentServiceClient) GetContentBySlug(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/GetContentBySlug", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) GetContent(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/GetContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) StoreContent(ctx context.Context, in *StoreContentRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/StoreContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) UpdateContent(ctx context.Context, in *UpdateContentRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/UpdateContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) DeleteContent(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/DeleteContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ContentService service

type ContentServiceServer interface {
	// Gets the content of specified page(slug)
	GetContentBySlug(context.Context, *ContentRequest) (*Content, error)
	GetContent(context.Context, *ContentIdRequest) (*Content, error)
	// Store the content of a new page(slug)
	StoreContent(context.Context, *StoreContentRequest) (*Content, error)
	// Update the content of an existing page
	UpdateContent(context.Context, *UpdateContentRequest) (*Content, error)
	// Delete an existing page along with its content
	DeleteContent(context.Context, *ContentIdRequest) (*google_protobuf3.Empty, error)
}

func RegisterContentServiceServer(s *grpc.Server, srv ContentServiceServer) {
	s.RegisterService(&_ContentService_serviceDesc, srv)
}

func _ContentService_GetContentBySlug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).GetContentBySlug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/GetContentBySlug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).GetContentBySlug(ctx, req.(*ContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_GetContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).GetContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/GetContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).GetContent(ctx, req.(*ContentIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_StoreContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).StoreContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/StoreContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).StoreContent(ctx, req.(*StoreContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_UpdateContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).UpdateContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/UpdateContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).UpdateContent(ctx, req.(*UpdateContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_DeleteContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).DeleteContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/DeleteContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).DeleteContent(ctx, req.(*ContentIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ContentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dictybase.content.ContentService",
	HandlerType: (*ContentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContentBySlug",
			Handler:    _ContentService_GetContentBySlug_Handler,
		},
		{
			MethodName: "GetContent",
			Handler:    _ContentService_GetContent_Handler,
		},
		{
			MethodName: "StoreContent",
			Handler:    _ContentService_StoreContent_Handler,
		},
		{
			MethodName: "UpdateContent",
			Handler:    _ContentService_UpdateContent_Handler,
		},
		{
			MethodName: "DeleteContent",
			Handler:    _ContentService_DeleteContent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content.proto",
}

func init() { proto.RegisterFile("content.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 901 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xdd, 0x8e, 0xdb, 0x44,
	0x14, 0xc6, 0xde, 0x74, 0xb7, 0x99, 0xed, 0x46, 0xe9, 0x74, 0x5b, 0xbc, 0x66, 0xcb, 0x2e, 0xee,
	0x96, 0x56, 0xed, 0xc6, 0x46, 0x41, 0x42, 0x2a, 0x95, 0x80, 0xb8, 0x29, 0xd5, 0x4a, 0x05, 0xad,
	0xbc, 0x45, 0xe2, 0x47, 0xa8, 0x9a, 0xc4, 0x53, 0x77, 0x48, 0xe2, 0x71, 0xed, 0x49, 0xb7, 0x6e,
	0xd5, 0x1b, 0x5e, 0x81, 0x07, 0x40, 0xe2, 0x06, 0x09, 0x2e, 0x78, 0x00, 0x1e, 0x83, 0x07, 0xa8,
	0xb4, 0xe2, 0x21, 0xb8, 0x44, 0x33, 0x1e, 0xff, 0x3b, 0x69, 0x6e, 0x92, 0xf1, 0x9c, 0xef, 0x9c,
	0xef, 0x9c, 0x6f, 0xce, 0x19, 0x0d, 0xd8, 0x1a, 0x53, 0x9f, 0x61, 0x9f, 0x99, 0x41, 0x48, 0x19,
	0x85, 0x17, 0x5d, 0x32, 0x66, 0xf1, 0x08, 0x45, 0xd8, 0x94, 0x06, 0x7d, 0xd7, 0xa3, 0xd4, 0x9b,
	0x62, 0x0b, 0x05, 0xc4, 0x42, 0xbe, 0x4f, 0x19, 0x62, 0x84, 0xfa, 0x51, 0xe2, 0xa0, 0xef, 0x4b,
	0xab, 0xf8, 0x1a, 0xcd, 0x9f, 0x58, 0x4f, 0x08, 0x9e, 0xba, 0x8f, 0x67, 0x28, 0x9a, 0x48, 0xc4,
	0x5e, 0x15, 0xc1, 0xc8, 0x0c, 0x47, 0x0c, 0xcd, 0x02, 0x09, 0x78, 0xaf, 0x0a, 0xc0, 0xb3, 0x80,
	0xc5, 0xd2, 0xb8, 0x53, 0x35, 0x22, 0x3f, 0x35, 0x5d, 0xcb, 0x72, 0x15, 0xb9, 0xfd, 0x14, 0x51,
	0x9f, 0xff, 0x07, 0x28, 0x9e, 0x52, 0xe4, 0x2e, 0x07, 0x85, 0xf8, 0xd9, 0x1c, 0x47, 0xb2, 0x6a,
	0xfd, 0x13, 0x8f, 0xb0, 0xa7, 0xf3, 0x91, 0x39, 0xa6, 0x33, 0x6b, 0x76, 0x4a, 0xd8, 0x84, 0x9e,
	0x5a, 0x1e, 0xed, 0x09, 0x63, 0xef, 0x39, 0x9a, 0x12, 0x17, 0x31, 0x1a, 0x46, 0x56, 0xb6, 0x4c,
	0xfc, 0x8c, 0x67, 0x60, 0xe3, 0x5e, 0xa2, 0x12, 0xec, 0x83, 0x96, 0x8b, 0x18, 0xd2, 0x94, 0x7d,
	0xe5, 0xe6, 0x66, 0xff, 0x7d, 0xb3, 0xa6, 0xa3, 0x29, 0x91, 0x43, 0xc4, 0x90, 0x23, 0xb0, 0xb0,
	0x0f, 0xce, 0x4d, 0x89, 0x3f, 0x89, 0x34, 0x55, 0x38, 0xed, 0x16, 0x9c, 0x50, 0x40, 0x4c, 0x99,
	0xab, 0xf9, 0x90, 0x63, 0x9c, 0x04, 0x6a, 0xfc, 0xa9, 0x80, 0xcd, 0x42, 0x24, 0x08, 0x41, 0x8b,
	0xc5, 0x01, 0x16, 0xbc, 0x6d, 0x47, 0xac, 0x61, 0x07, 0xa8, 0xc4, 0x15, 0x41, 0xd7, 0x1c, 0x95,
	0xb8, 0x70, 0x08, 0x00, 0x62, 0x2c, 0x24, 0xa3, 0x39, 0xc3, 0x91, 0xb6, 0x26, 0xc8, 0x0e, 0x16,
	0x67, 0x38, 0xc8, 0xb0, 0x4e, 0xc1, 0x2f, 0xcf, 0xb6, 0xb5, 0x7a, 0xb6, 0xbf, 0xab, 0xe0, 0x62,
	0x2d, 0x2a, 0xcf, 0xd9, 0x47, 0xb3, 0x2c, 0x67, 0xbe, 0xe6, 0x7b, 0xd1, 0x74, 0xee, 0x89, 0xac,
	0xdb, 0x8e, 0x58, 0xc3, 0xab, 0x00, 0x8c, 0x43, 0x8c, 0x18, 0x76, 0x1f, 0x8f, 0x62, 0x91, 0xf7,
	0x9a, 0xd3, 0x96, 0x3b, 0x76, 0xcc, 0xcd, 0xf3, 0xc0, 0x4d, 0xcd, 0xad, 0xc4, 0x2c, 0x77, 0xec,
	0x18, 0xde, 0xc9, 0xbd, 0x11, 0xd3, 0xce, 0x89, 0xa4, 0x75, 0x33, 0x69, 0x27, 0x33, 0x6d, 0x27,
	0xf3, 0x51, 0xda, 0x8c, 0x59, 0xe4, 0x01, 0xe3, 0xae, 0x69, 0x64, 0xc4, 0xb4, 0xf5, 0xb7, 0xbb,
	0x4a, 0xf4, 0x80, 0x41, 0x0d, 0x6c, 0x48, 0x39, 0xb5, 0x0d, 0x51, 0x4a, 0xfa, 0x09, 0x77, 0x41,
	0x9b, 0x57, 0x1a, 0x05, 0x68, 0x8c, 0xb5, 0xf3, 0xc2, 0x96, 0x6f, 0x18, 0x07, 0xa0, 0x23, 0x85,
	0x72, 0x92, 0xd6, 0xcc, 0x14, 0x51, 0x72, 0x45, 0x0c, 0x03, 0x74, 0x25, 0xea, 0xc8, 0x4d, 0x71,
	0xc9, 0x69, 0x2b, 0xe9, 0x69, 0x1b, 0x7f, 0x29, 0x60, 0xfb, 0x6b, 0x7c, 0x5a, 0x97, 0xfd, 0x66,
	0x51, 0x76, 0x7b, 0xfb, 0xec, 0xcd, 0x5e, 0x17, 0x74, 0x7e, 0x40, 0xbd, 0x97, 0x87, 0x83, 0xde,
	0xcb, 0xc3, 0x8f, 0x7a, 0x77, 0x7e, 0xbc, 0x2d, 0x0f, 0xe3, 0x7a, 0x49, 0x78, 0xd1, 0x48, 0xf6,
	0xfa, 0xd9, 0x9b, 0x3d, 0xb5, 0xfb, 0x4e, 0xf1, 0x00, 0xf6, 0xf3, 0x5a, 0xd7, 0x44, 0x4c, 0x81,
	0xf9, 0x56, 0xc9, 0x6b, 0x3e, 0x28, 0xd6, 0xdc, 0x2a, 0x61, 0x0a, 0xb5, 0xff, 0xad, 0x80, 0x4b,
	0x27, 0x8c, 0x86, 0xb8, 0xa2, 0xc0, 0xe7, 0xa5, 0x99, 0xba, 0xdd, 0xd0, 0xb1, 0x0d, 0x5e, 0x66,
	0x3e, 0x60, 0xfa, 0x18, 0xb4, 0x16, 0x0e, 0xc9, 0x83, 0xd2, 0x50, 0x24, 0x13, 0x78, 0xa3, 0x81,
	0xa2, 0x49, 0xca, 0xe2, 0x5c, 0x18, 0x2e, 0xd8, 0xb9, 0xff, 0x82, 0x44, 0x8c, 0xf8, 0x5e, 0x5d,
	0xf3, 0xeb, 0xa5, 0x1e, 0x55, 0xca, 0x4a, 0xe6, 0xbd, 0x5a, 0x50, 0x52, 0x6d, 0x54, 0xd2, 0xf8,
	0x55, 0x05, 0xdb, 0xdf, 0x08, 0x7c, 0x45, 0xa4, 0x2f, 0x4a, 0x22, 0x1d, 0x36, 0x54, 0xd0, 0xe4,
	0x56, 0x50, 0xa9, 0x76, 0x5d, 0xdc, 0x05, 0x9b, 0x49, 0x66, 0xe2, 0x16, 0x97, 0xf7, 0x45, 0xbd,
	0xfd, 0xbf, 0xe4, 0x17, 0xfd, 0x57, 0x28, 0x9a, 0x38, 0xb2, 0x44, 0xbe, 0xd6, 0x5f, 0x2c, 0x91,
	0xbc, 0x4a, 0xf4, 0xb0, 0xe1, 0x5e, 0x6a, 0x2a, 0x60, 0xa1, 0xbc, 0xc5, 0x73, 0xe8, 0xff, 0xd1,
	0xca, 0x46, 0xe8, 0x04, 0x87, 0xcf, 0xc9, 0x18, 0xc3, 0x00, 0x74, 0x1f, 0x60, 0x26, 0x37, 0xed,
	0xf8, 0x84, 0x5f, 0x2a, 0x1f, 0x2c, 0xbe, 0xf8, 0xa4, 0x36, 0xba, 0xbe, 0x18, 0x62, 0x5c, 0xfd,
	0xf9, 0x9f, 0x7f, 0x7f, 0x51, 0xdf, 0x85, 0x97, 0x2d, 0x69, 0x89, 0x2c, 0x3e, 0x99, 0xd6, 0x2b,
	0xfe, 0xfb, 0x1a, 0x62, 0x00, 0x72, 0x46, 0x78, 0x6d, 0x71, 0xa0, 0x6c, 0x7e, 0x97, 0xb2, 0x5d,
	0x11, 0x6c, 0x5d, 0xd8, 0xc9, 0xd9, 0x5e, 0x11, 0xf7, 0x35, 0x7c, 0x0a, 0x2e, 0x14, 0x5b, 0x1f,
	0x7e, 0xb8, 0xda, 0x6c, 0x2c, 0xe5, 0xda, 0x16, 0x5c, 0x1d, 0xa3, 0x9d, 0x71, 0x7d, 0xaa, 0xdc,
	0x82, 0x14, 0x6c, 0x95, 0xfa, 0x07, 0xde, 0x58, 0xb1, 0xc3, 0x96, 0x72, 0xed, 0x08, 0xae, 0x4b,
	0xfd, 0x4a, 0x5d, 0x9c, 0xd0, 0x05, 0x5b, 0x43, 0x3c, 0xc5, 0x39, 0xe1, 0x4a, 0x22, 0x5e, 0xa9,
	0xb5, 0xe7, 0x7d, 0xfe, 0x88, 0x48, 0x05, 0xbc, 0x55, 0x21, 0xb2, 0xe7, 0xe0, 0x32, 0x0d, 0xbd,
	0x7a, 0x64, 0xfb, 0x82, 0x0c, 0x7d, 0xcc, 0xe3, 0x1c, 0x2b, 0xdf, 0x7f, 0x56, 0x78, 0x1a, 0x08,
	0xb4, 0xcd, 0x9f, 0x12, 0x1e, 0xed, 0x79, 0xd8, 0x17, 0x5c, 0x56, 0x16, 0x03, 0x05, 0x24, 0x4a,
	0x69, 0xee, 0xca, 0xff, 0xff, 0x14, 0xe5, 0x37, 0xf5, 0xfc, 0xf0, 0xe8, 0xde, 0xa3, 0xef, 0x06,
	0xc7, 0x47, 0xa3, 0x75, 0xe1, 0xf2, 0xf1, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x9c, 0xb1, 0x27,
	0x38, 0x76, 0x09, 0x00, 0x00,
}
