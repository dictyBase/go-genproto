// Code generated by protoc-gen-go. DO NOT EDIT.
// source: content.proto

/*
Package content is a generated protocol buffer package.

It is generated from these files:
	content.proto

It has these top-level messages:
	Content
	ContentData
	ContentAttributes
	ContentRequest
	ContentIdRequest
	StoreContentRequest
	ExistingContentAttributes
	UpdateContentRequest
	UpdateContentIdRequest
*/
package content

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "google.golang.org/genproto/protobuf/field_mask"
import google_protobuf2 "github.com/golang/protobuf/ptypes/timestamp"
import google_protobuf3 "github.com/golang/protobuf/ptypes/empty"
import _ "github.com/golang/protobuf/ptypes/any"
import dictybase_api_jsonapi "github.com/dictyBase/go-genproto/dictybaseapis/api/jsonapi"
import _ "github.com/dictyBase/go-genproto/dictybaseapis/api/jsonapi"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Content struct {
	Data  *ContentData                 `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Links *dictybase_api_jsonapi.Links `protobuf:"bytes,2,opt,name=links" json:"links,omitempty"`
}

func (m *Content) Reset()                    { *m = Content{} }
func (m *Content) String() string            { return proto.CompactTextString(m) }
func (*Content) ProtoMessage()               {}
func (*Content) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Content) GetData() *ContentData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Content) GetLinks() *dictybase_api_jsonapi.Links {
	if m != nil {
		return m.Links
	}
	return nil
}

type ContentData struct {
	// The resource name
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Unique id
	Id         int64                        `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Attributes *ContentAttributes           `protobuf:"bytes,3,opt,name=attributes" json:"attributes,omitempty"`
	Links      *dictybase_api_jsonapi.Links `protobuf:"bytes,4,opt,name=links" json:"links,omitempty"`
}

func (m *ContentData) Reset()                    { *m = ContentData{} }
func (m *ContentData) String() string            { return proto.CompactTextString(m) }
func (*ContentData) ProtoMessage()               {}
func (*ContentData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ContentData) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ContentData) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ContentData) GetAttributes() *ContentAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *ContentData) GetLinks() *dictybase_api_jsonapi.Links {
	if m != nil {
		return m.Links
	}
	return nil
}

// Definition for various content fields
type ContentAttributes struct {
	// page name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// page slug
	Slug string `protobuf:"bytes,2,opt,name=slug" json:"slug,omitempty"`
	// id of the user who created the content
	CreatedBy int64 `protobuf:"varint,3,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	// id of the user who updated the content
	UpdatedBy int64 `protobuf:"varint,4,opt,name=updated_by,json=updatedBy" json:"updated_by,omitempty"`
	// Timestamp for creation and update
	CreatedAt *google_protobuf2.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	UpdatedAt *google_protobuf2.Timestamp `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
	// serialized page content
	Content string `protobuf:"bytes,7,opt,name=content" json:"content,omitempty"`
	// namespace for the page
	Namespace string `protobuf:"bytes,8,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *ContentAttributes) Reset()                    { *m = ContentAttributes{} }
func (m *ContentAttributes) String() string            { return proto.CompactTextString(m) }
func (*ContentAttributes) ProtoMessage()               {}
func (*ContentAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ContentAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContentAttributes) GetSlug() string {
	if m != nil {
		return m.Slug
	}
	return ""
}

func (m *ContentAttributes) GetCreatedBy() int64 {
	if m != nil {
		return m.CreatedBy
	}
	return 0
}

func (m *ContentAttributes) GetUpdatedBy() int64 {
	if m != nil {
		return m.UpdatedBy
	}
	return 0
}

func (m *ContentAttributes) GetCreatedAt() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *ContentAttributes) GetUpdatedAt() *google_protobuf2.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *ContentAttributes) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *ContentAttributes) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type ContentRequest struct {
	// Url slug
	// Look here https://en.wikipedia.org/wiki/Semantic_URL#Slug to know about slug
	// The slug name should be unique
	Slug string `protobuf:"bytes,1,opt,name=slug" json:"slug,omitempty"`
}

func (m *ContentRequest) Reset()                    { *m = ContentRequest{} }
func (m *ContentRequest) String() string            { return proto.CompactTextString(m) }
func (*ContentRequest) ProtoMessage()               {}
func (*ContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ContentRequest) GetSlug() string {
	if m != nil {
		return m.Slug
	}
	return ""
}

type ContentIdRequest struct {
	// Unique id to identify content
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *ContentIdRequest) Reset()                    { *m = ContentIdRequest{} }
func (m *ContentIdRequest) String() string            { return proto.CompactTextString(m) }
func (*ContentIdRequest) ProtoMessage()               {}
func (*ContentIdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ContentIdRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// Definition for storing new content
type StoreContentRequest struct {
	Data *StoreContentRequest_Data `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *StoreContentRequest) Reset()                    { *m = StoreContentRequest{} }
func (m *StoreContentRequest) String() string            { return proto.CompactTextString(m) }
func (*StoreContentRequest) ProtoMessage()               {}
func (*StoreContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *StoreContentRequest) GetData() *StoreContentRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type StoreContentRequest_Data struct {
	// resource name
	Type       string                                         `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Attributes *StoreContentRequest_Data_NewContentAttributes `protobuf:"bytes,2,opt,name=attributes" json:"attributes,omitempty"`
}

func (m *StoreContentRequest_Data) Reset()                    { *m = StoreContentRequest_Data{} }
func (m *StoreContentRequest_Data) String() string            { return proto.CompactTextString(m) }
func (*StoreContentRequest_Data) ProtoMessage()               {}
func (*StoreContentRequest_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *StoreContentRequest_Data) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *StoreContentRequest_Data) GetAttributes() *StoreContentRequest_Data_NewContentAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// Definition for fields that are needed for storing the content
type StoreContentRequest_Data_NewContentAttributes struct {
	// page name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// user id who is creating this content
	// The existence of user will be verified(not implemented yet)
	// using the `user` microservice backend.
	CreatedBy int64 `protobuf:"varint,2,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	// page content, expected to be serialized `JSON` string.
	Content string `protobuf:"bytes,3,opt,name=content" json:"content,omitempty"`
	// namespace for the page, it is prepended to the
	// name to generate an unique slug.
	Namespace string `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *StoreContentRequest_Data_NewContentAttributes) Reset() {
	*m = StoreContentRequest_Data_NewContentAttributes{}
}
func (m *StoreContentRequest_Data_NewContentAttributes) String() string {
	return proto.CompactTextString(m)
}
func (*StoreContentRequest_Data_NewContentAttributes) ProtoMessage() {}
func (*StoreContentRequest_Data_NewContentAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0, 0}
}

func (m *StoreContentRequest_Data_NewContentAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StoreContentRequest_Data_NewContentAttributes) GetCreatedBy() int64 {
	if m != nil {
		return m.CreatedBy
	}
	return 0
}

func (m *StoreContentRequest_Data_NewContentAttributes) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *StoreContentRequest_Data_NewContentAttributes) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Fields that can be updated
// Changing either or both of name and namespace
// attributes alter the slug for the page
type ExistingContentAttributes struct {
	// page name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// user id who is updating this content
	// The existence of user will be verified(not implemented yet)
	// using the `user` microservice backend.
	UpdatedBy int64 `protobuf:"varint,2,opt,name=updated_by,json=updatedBy" json:"updated_by,omitempty"`
	// content
	Content string `protobuf:"bytes,3,opt,name=content" json:"content,omitempty"`
	// namespace
	Namespace string `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *ExistingContentAttributes) Reset()                    { *m = ExistingContentAttributes{} }
func (m *ExistingContentAttributes) String() string            { return proto.CompactTextString(m) }
func (*ExistingContentAttributes) ProtoMessage()               {}
func (*ExistingContentAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ExistingContentAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExistingContentAttributes) GetUpdatedBy() int64 {
	if m != nil {
		return m.UpdatedBy
	}
	return 0
}

func (m *ExistingContentAttributes) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *ExistingContentAttributes) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Definition for updating any existing content
type UpdateContentRequest struct {
	Data *UpdateContentRequest_Data `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Slug string                     `protobuf:"bytes,2,opt,name=slug" json:"slug,omitempty"`
	// An optional mask specifying which fields to update.
	// Presence of this field allow partial updates.
	UpdateMask *google_protobuf1.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateContentRequest) Reset()                    { *m = UpdateContentRequest{} }
func (m *UpdateContentRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateContentRequest) ProtoMessage()               {}
func (*UpdateContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UpdateContentRequest) GetData() *UpdateContentRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UpdateContentRequest) GetSlug() string {
	if m != nil {
		return m.Slug
	}
	return ""
}

func (m *UpdateContentRequest) GetUpdateMask() *google_protobuf1.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type UpdateContentRequest_Data struct {
	// resource name
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// unique id
	Id         int64                      `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Attributes *ExistingContentAttributes `protobuf:"bytes,3,opt,name=attributes" json:"attributes,omitempty"`
}

func (m *UpdateContentRequest_Data) Reset()                    { *m = UpdateContentRequest_Data{} }
func (m *UpdateContentRequest_Data) String() string            { return proto.CompactTextString(m) }
func (*UpdateContentRequest_Data) ProtoMessage()               {}
func (*UpdateContentRequest_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *UpdateContentRequest_Data) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *UpdateContentRequest_Data) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateContentRequest_Data) GetAttributes() *ExistingContentAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type UpdateContentIdRequest struct {
	Data *UpdateContentIdRequest_Data `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Id   int64                        `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// An optional mask specifying which fields to update.
	// Presence of this field allow partial updates.
	UpdateMask *google_protobuf1.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateContentIdRequest) Reset()                    { *m = UpdateContentIdRequest{} }
func (m *UpdateContentIdRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateContentIdRequest) ProtoMessage()               {}
func (*UpdateContentIdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UpdateContentIdRequest) GetData() *UpdateContentIdRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UpdateContentIdRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateContentIdRequest) GetUpdateMask() *google_protobuf1.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type UpdateContentIdRequest_Data struct {
	// resource name
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// unique id
	Id         int64                      `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Attributes *ExistingContentAttributes `protobuf:"bytes,3,opt,name=attributes" json:"attributes,omitempty"`
}

func (m *UpdateContentIdRequest_Data) Reset()                    { *m = UpdateContentIdRequest_Data{} }
func (m *UpdateContentIdRequest_Data) String() string            { return proto.CompactTextString(m) }
func (*UpdateContentIdRequest_Data) ProtoMessage()               {}
func (*UpdateContentIdRequest_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *UpdateContentIdRequest_Data) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *UpdateContentIdRequest_Data) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateContentIdRequest_Data) GetAttributes() *ExistingContentAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func init() {
	proto.RegisterType((*Content)(nil), "dictybase.content.Content")
	proto.RegisterType((*ContentData)(nil), "dictybase.content.ContentData")
	proto.RegisterType((*ContentAttributes)(nil), "dictybase.content.ContentAttributes")
	proto.RegisterType((*ContentRequest)(nil), "dictybase.content.ContentRequest")
	proto.RegisterType((*ContentIdRequest)(nil), "dictybase.content.ContentIdRequest")
	proto.RegisterType((*StoreContentRequest)(nil), "dictybase.content.StoreContentRequest")
	proto.RegisterType((*StoreContentRequest_Data)(nil), "dictybase.content.StoreContentRequest.Data")
	proto.RegisterType((*StoreContentRequest_Data_NewContentAttributes)(nil), "dictybase.content.StoreContentRequest.Data.NewContentAttributes")
	proto.RegisterType((*ExistingContentAttributes)(nil), "dictybase.content.ExistingContentAttributes")
	proto.RegisterType((*UpdateContentRequest)(nil), "dictybase.content.UpdateContentRequest")
	proto.RegisterType((*UpdateContentRequest_Data)(nil), "dictybase.content.UpdateContentRequest.Data")
	proto.RegisterType((*UpdateContentIdRequest)(nil), "dictybase.content.UpdateContentIdRequest")
	proto.RegisterType((*UpdateContentIdRequest_Data)(nil), "dictybase.content.UpdateContentIdRequest.Data")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ContentService service

type ContentServiceClient interface {
	// Gets the content of specified page(slug)
	// Look here https://en.wikipedia.org/wiki/Semantic_URL#Slug to know about slug
	GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*Content, error)
	GetContentById(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*Content, error)
	// Store the content of a new page(slug)
	StoreContent(ctx context.Context, in *StoreContentRequest, opts ...grpc.CallOption) (*Content, error)
	// Update the content of an existing page(slug)
	UpdateContent(ctx context.Context, in *UpdateContentRequest, opts ...grpc.CallOption) (*Content, error)
	UpdateContentById(ctx context.Context, in *UpdateContentIdRequest, opts ...grpc.CallOption) (*Content, error)
	// Delete an existing page(slug) along with its content
	DeleteContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	DeleteContentById(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
}

type contentServiceClient struct {
	cc *grpc.ClientConn
}

func NewContentServiceClient(cc *grpc.ClientConn) ContentServiceClient {
	return &contentServiceClient{cc}
}

func (c *contentServiceClient) GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/GetContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) GetContentById(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/GetContentById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) StoreContent(ctx context.Context, in *StoreContentRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/StoreContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) UpdateContent(ctx context.Context, in *UpdateContentRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/UpdateContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) UpdateContentById(ctx context.Context, in *UpdateContentIdRequest, opts ...grpc.CallOption) (*Content, error) {
	out := new(Content)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/UpdateContentById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) DeleteContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/DeleteContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentServiceClient) DeleteContentById(ctx context.Context, in *ContentIdRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/dictybase.content.ContentService/DeleteContentById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ContentService service

type ContentServiceServer interface {
	// Gets the content of specified page(slug)
	// Look here https://en.wikipedia.org/wiki/Semantic_URL#Slug to know about slug
	GetContent(context.Context, *ContentRequest) (*Content, error)
	GetContentById(context.Context, *ContentIdRequest) (*Content, error)
	// Store the content of a new page(slug)
	StoreContent(context.Context, *StoreContentRequest) (*Content, error)
	// Update the content of an existing page(slug)
	UpdateContent(context.Context, *UpdateContentRequest) (*Content, error)
	UpdateContentById(context.Context, *UpdateContentIdRequest) (*Content, error)
	// Delete an existing page(slug) along with its content
	DeleteContent(context.Context, *ContentRequest) (*google_protobuf3.Empty, error)
	DeleteContentById(context.Context, *ContentIdRequest) (*google_protobuf3.Empty, error)
}

func RegisterContentServiceServer(s *grpc.Server, srv ContentServiceServer) {
	s.RegisterService(&_ContentService_serviceDesc, srv)
}

func _ContentService_GetContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).GetContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/GetContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).GetContent(ctx, req.(*ContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_GetContentById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).GetContentById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/GetContentById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).GetContentById(ctx, req.(*ContentIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_StoreContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).StoreContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/StoreContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).StoreContent(ctx, req.(*StoreContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_UpdateContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).UpdateContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/UpdateContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).UpdateContent(ctx, req.(*UpdateContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_UpdateContentById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContentIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).UpdateContentById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/UpdateContentById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).UpdateContentById(ctx, req.(*UpdateContentIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_DeleteContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).DeleteContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/DeleteContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).DeleteContent(ctx, req.(*ContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentService_DeleteContentById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentServiceServer).DeleteContentById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dictybase.content.ContentService/DeleteContentById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentServiceServer).DeleteContentById(ctx, req.(*ContentIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ContentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dictybase.content.ContentService",
	HandlerType: (*ContentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContent",
			Handler:    _ContentService_GetContent_Handler,
		},
		{
			MethodName: "GetContentById",
			Handler:    _ContentService_GetContentById_Handler,
		},
		{
			MethodName: "StoreContent",
			Handler:    _ContentService_StoreContent_Handler,
		},
		{
			MethodName: "UpdateContent",
			Handler:    _ContentService_UpdateContent_Handler,
		},
		{
			MethodName: "UpdateContentById",
			Handler:    _ContentService_UpdateContentById_Handler,
		},
		{
			MethodName: "DeleteContent",
			Handler:    _ContentService_DeleteContent_Handler,
		},
		{
			MethodName: "DeleteContentById",
			Handler:    _ContentService_DeleteContentById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content.proto",
}

func init() { proto.RegisterFile("content.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 872 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x4d, 0x4f, 0xe3, 0x46,
	0x18, 0x96, 0x9d, 0xf0, 0x91, 0x01, 0x22, 0x32, 0x7c, 0xc8, 0x18, 0xda, 0x52, 0x83, 0xfa, 0x41,
	0x5b, 0x47, 0x4a, 0x4f, 0x2d, 0x52, 0x4b, 0x42, 0x68, 0x15, 0x89, 0x56, 0xc8, 0xd0, 0x43, 0x7b,
	0xa1, 0x93, 0x78, 0x30, 0x53, 0x12, 0xdb, 0xc4, 0xe3, 0x16, 0xab, 0x42, 0x6a, 0x7b, 0xe0, 0x0f,
	0xf4, 0x1f, 0xec, 0x1e, 0xf6, 0xb0, 0x3f, 0x67, 0x4f, 0x7b, 0xdf, 0x1f, 0xb1, 0xc7, 0xd5, 0x8c,
	0xc7, 0x9f, 0x71, 0x4c, 0x76, 0x6f, 0x7b, 0xca, 0x64, 0xde, 0xe7, 0x7d, 0x9f, 0xf7, 0xe3, 0x99,
	0x37, 0x01, 0x2b, 0x03, 0xc7, 0xa6, 0xd8, 0xa6, 0xba, 0x3b, 0x76, 0xa8, 0x03, 0x1b, 0x26, 0x19,
	0xd0, 0xa0, 0x8f, 0x3c, 0xac, 0x0b, 0x83, 0xba, 0x63, 0x39, 0x8e, 0x35, 0xc4, 0x4d, 0xe4, 0x92,
	0x26, 0xb2, 0x6d, 0x87, 0x22, 0x4a, 0x1c, 0xdb, 0x0b, 0x1d, 0xd4, 0x5d, 0x61, 0xe5, 0xdf, 0xfa,
	0xfe, 0x55, 0xf3, 0x8a, 0xe0, 0xa1, 0x79, 0x39, 0x42, 0xde, 0x8d, 0x40, 0x7c, 0x94, 0x47, 0x50,
	0x32, 0xc2, 0x1e, 0x45, 0x23, 0x57, 0x00, 0xb6, 0xf3, 0x00, 0x3c, 0x72, 0x69, 0x20, 0x8c, 0x5b,
	0x79, 0x23, 0xb2, 0x23, 0xd3, 0x5e, 0x9c, 0x2b, 0xcf, 0xed, 0x0f, 0xcf, 0xb1, 0xd9, 0xa7, 0x8b,
	0x82, 0xa1, 0x83, 0xcc, 0x72, 0xd0, 0x18, 0xdf, 0xfa, 0xd8, 0x13, 0x55, 0x6b, 0xb7, 0x60, 0xe1,
	0x38, 0xac, 0x16, 0xb6, 0x40, 0xd5, 0x44, 0x14, 0x29, 0xd2, 0xae, 0xf4, 0xd9, 0x52, 0xeb, 0x43,
	0x7d, 0xa2, 0x1f, 0xba, 0x40, 0x76, 0x11, 0x45, 0x06, 0xc7, 0xc2, 0x16, 0x98, 0x1b, 0x12, 0xfb,
	0xc6, 0x53, 0x64, 0xee, 0xb4, 0x93, 0x72, 0x42, 0x2e, 0xd1, 0x05, 0xa7, 0x7e, 0xca, 0x30, 0x46,
	0x08, 0xd5, 0x9e, 0x4b, 0x60, 0x29, 0x15, 0x09, 0x42, 0x50, 0xa5, 0x81, 0x8b, 0x39, 0x6f, 0xcd,
	0xe0, 0x67, 0x58, 0x07, 0x32, 0x31, 0x79, 0xd0, 0x8a, 0x21, 0x13, 0x13, 0x76, 0x01, 0x40, 0x94,
	0x8e, 0x49, 0xdf, 0xa7, 0xd8, 0x53, 0x2a, 0x9c, 0x6c, 0x7f, 0x7a, 0x86, 0xed, 0x18, 0x6b, 0xa4,
	0xfc, 0x92, 0x6c, 0xab, 0xb3, 0x67, 0xfb, 0x4c, 0x06, 0x8d, 0x89, 0xa8, 0x2c, 0x67, 0x1b, 0x8d,
	0xe2, 0x9c, 0xd9, 0x99, 0xdd, 0x79, 0x43, 0xdf, 0xe2, 0x59, 0xd7, 0x0c, 0x7e, 0x86, 0x1f, 0x00,
	0x30, 0x18, 0x63, 0x44, 0xb1, 0x79, 0xd9, 0x0f, 0x78, 0xde, 0x15, 0xa3, 0x26, 0x6e, 0x3a, 0x01,
	0x33, 0xfb, 0xae, 0x19, 0x99, 0xab, 0xa1, 0x59, 0xdc, 0x74, 0x02, 0xf8, 0x4d, 0xe2, 0x8d, 0xa8,
	0x32, 0xc7, 0x93, 0x56, 0xf5, 0x50, 0x16, 0x7a, 0x24, 0x0b, 0xfd, 0x22, 0x12, 0x55, 0x1c, 0xb9,
	0x4d, 0x99, 0x6b, 0x14, 0x19, 0x51, 0x65, 0xfe, 0x71, 0x57, 0x81, 0x6e, 0x53, 0xa8, 0x80, 0x05,
	0xd1, 0x4e, 0x65, 0x81, 0x97, 0x12, 0x7d, 0x85, 0x3b, 0xa0, 0xc6, 0x2a, 0xf5, 0x5c, 0x34, 0xc0,
	0xca, 0x22, 0xb7, 0x25, 0x17, 0xda, 0x3e, 0xa8, 0x8b, 0x46, 0x19, 0xa1, 0xc4, 0xe2, 0x8e, 0x48,
	0x49, 0x47, 0x34, 0x0d, 0xac, 0x0a, 0x54, 0xcf, 0x8c, 0x70, 0xe1, 0xb4, 0xa5, 0x68, 0xda, 0xda,
	0x4b, 0x19, 0xac, 0x9d, 0x53, 0x67, 0x8c, 0x73, 0xf1, 0xbe, 0xcf, 0x28, 0xf4, 0x8b, 0x82, 0xf9,
	0x17, 0x78, 0xe9, 0x89, 0x5c, 0xd5, 0x7f, 0x64, 0x50, 0x9d, 0xaa, 0xb9, 0xdf, 0x33, 0x1a, 0x0b,
	0x05, 0x7d, 0xf4, 0x16, 0x1c, 0xfa, 0xcf, 0xf8, 0xaf, 0x52, 0xfd, 0xa9, 0xff, 0x4a, 0x60, 0xbd,
	0x08, 0x54, 0x28, 0xa7, 0xac, 0x74, 0xe4, 0xbc, 0x74, 0x52, 0x53, 0xaa, 0x94, 0x4c, 0xa9, 0x9a,
	0x9f, 0xd2, 0x83, 0x04, 0xb6, 0x4e, 0xee, 0x88, 0x47, 0x89, 0x6d, 0xcd, 0x9c, 0x48, 0x4a, 0xa4,
	0x72, 0x5e, 0xa4, 0xef, 0x9a, 0xc8, 0x53, 0x19, 0xac, 0xff, 0xc2, 0xa3, 0xe4, 0xa6, 0x7c, 0x94,
	0x99, 0xf2, 0x97, 0x05, 0x13, 0x28, 0x72, 0x4b, 0x8d, 0xb9, 0xf0, 0x25, 0x1e, 0x82, 0xa5, 0x30,
	0x67, 0xbe, 0xa0, 0xc5, 0x0a, 0x99, 0x7c, 0x11, 0x3f, 0xb0, 0x1d, 0xfe, 0x13, 0xf2, 0x6e, 0x0c,
	0x51, 0x34, 0x3b, 0xab, 0x77, 0x25, 0xb2, 0xc9, 0xaf, 0xaa, 0xd3, 0x82, 0x55, 0x55, 0x54, 0xc4,
	0xd4, 0x21, 0xa4, 0x25, 0xc3, 0xba, 0xb4, 0x99, 0x29, 0x37, 0x79, 0x35, 0x9d, 0x4c, 0x9f, 0xf4,
	0xc7, 0xfa, 0x14, 0x3b, 0xa6, 0x3b, 0x95, 0x4f, 0xfe, 0xfd, 0xec, 0x52, 0xeb, 0x61, 0x3e, 0xde,
	0x3d, 0xe7, 0x78, 0xfc, 0x27, 0x19, 0x60, 0x88, 0x01, 0xf8, 0x11, 0xd3, 0xe8, 0xb7, 0xed, 0xe3,
	0xe9, 0xbf, 0x15, 0xa2, 0x2b, 0xaa, 0x3a, 0x1d, 0xa2, 0x29, 0xff, 0xbd, 0x78, 0xf5, 0xbf, 0x0c,
	0xe1, 0x6a, 0x53, 0x58, 0xbc, 0xe6, 0xdf, 0x4c, 0x55, 0xf7, 0x90, 0x80, 0x7a, 0x42, 0xd3, 0x09,
	0x7a, 0x26, 0xdc, 0x9b, 0x1e, 0x27, 0x1e, 0x41, 0x29, 0xd9, 0x26, 0x27, 0x5b, 0x85, 0xf5, 0x14,
	0x19, 0x31, 0xef, 0xe1, 0x35, 0x58, 0x4e, 0xaf, 0x1e, 0xf8, 0xc9, 0x6c, 0xbb, 0xa9, 0x94, 0x6b,
	0x9d, 0x73, 0xd5, 0xb5, 0x5a, 0xcc, 0xf5, 0xad, 0x74, 0x00, 0x6f, 0xc1, 0x4a, 0x46, 0x3a, 0xf0,
	0xd3, 0x19, 0x1f, 0x61, 0x29, 0xd7, 0x36, 0xe7, 0xda, 0x68, 0x4d, 0x34, 0x91, 0x51, 0xfa, 0xa0,
	0x91, 0x09, 0xc8, 0x5b, 0xf9, 0xf9, 0xcc, 0x9a, 0x2e, 0x25, 0xde, 0xe2, 0xc4, 0x6b, 0xad, 0x5c,
	0x43, 0x19, 0xad, 0x09, 0x56, 0xba, 0x78, 0x88, 0x93, 0x4a, 0x67, 0x10, 0xca, 0xe6, 0xc4, 0x73,
	0x38, 0x61, 0xff, 0xda, 0x22, 0x91, 0x1c, 0x4c, 0x8a, 0xe4, 0x1a, 0x34, 0x32, 0x2c, 0xb3, 0xeb,
	0x64, 0x1a, 0x97, 0xd0, 0xc8, 0x41, 0xae, 0xa4, 0x8e, 0x0f, 0x36, 0x9c, 0xb1, 0x35, 0x19, 0xb9,
	0xb3, 0x2c, 0x42, 0x9f, 0xb1, 0x38, 0x67, 0xd2, 0x6f, 0xdf, 0x59, 0x84, 0x5e, 0xfb, 0x7d, 0x7d,
	0xe0, 0x8c, 0x9a, 0x1c, 0xdd, 0x61, 0xff, 0x13, 0x2d, 0xe7, 0x2b, 0x0b, 0xdb, 0x9c, 0xab, 0x19,
	0xc7, 0x40, 0x2e, 0xf1, 0x22, 0x9a, 0x43, 0xf1, 0xf9, 0x5a, 0x92, 0x9e, 0xc8, 0x8b, 0xdd, 0xde,
	0xf1, 0xc5, 0xaf, 0xed, 0xb3, 0x5e, 0x7f, 0x9e, 0xbb, 0x7c, 0xfd, 0x26, 0x00, 0x00, 0xff, 0xff,
	0x56, 0x2e, 0x11, 0xff, 0x53, 0x0b, 0x00, 0x00,
}
